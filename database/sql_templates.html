<!DOCTYPE HTML>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <title>Templates for Basic SQL Queries</title>
    <meta name="description" content="Six templates for basic SQL queries that include filters, sorting, inner joins, scalar functions, aggregate functions, and grouping.">
    <meta name="keywords" content="SQL, MySQL, SELECT, query template">
    <link rel="canonical" href="https://barzeer.github.io/database/sql_templates.html">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="../site/smart_dev.js"></script>
    <script src="../site/article.js"></script>
    <script src="../site/hljs/highlight.min.js"></script>
    <link rel="icon" type="image/png" href="../site/icons/icon.png">
    <link rel="stylesheet" type="text/css" href="../site/style.css">
    <link rel="stylesheet" href="../site/hljs/vscode.css">
</head>

<body>
<article>
<h1>Templates for Basic SQL Queries</h1>

<p>Here are six templates that may help you write SQL queries. Within
the templates, the words written in UPPERCASE are SQL keywords and the
words written in <var>lowercase italics</var> are the ones that you should
replace for each specific query.</p>

<h3>Simple Query</h3>
<div class="pre">
<pre class="code language-sql">SELECT <var>columns</var>
FROM <var>schema.table</var>
WHERE <var>filter</var>
ORDER BY <var>columns</var>
LIMIT <var>offset</var>, <var>count</var></pre></div>

<h3>Arithmetic Operators</h3>
<p>The arithmetic operators cause the database server to perform
arithmetic on the data in cells. The arithmetic operators available in
MySQL include &minus; (negation), * (multiplication), / (division), DIV
(integer division), MOD (modulus), + (addition), and &minus;
(subtraction).</p>

<div class="pre">
<pre class="code language-sql">SELECT <var>column</var> <var>operator</var> <var>column</var> AS <var>alias</var>, &hellip;
FROM <var>schema.table</var>
WHERE <var>filter</var>
ORDER BY <var>columns</var>
LIMIT <var>offset</var>, <var>count</var></pre></div>

<h3>Scalar Functions</h3>
<p>Scalar functions are functions that operate on the data in one row.
The scalar functions available in MySQL include YEAR(), MONTH(),
CONCAT(), LOWER(), UPPER(), SUBSTRING(), POW(), ROUND(), and
SQRT()</p>

<div class="pre">
<pre class="code language-sql">SELECT <var>func(column)</var> AS <var>alias</var>, &hellip;
FROM <var>schema.table</var>
WHERE <var>filter</var>
ORDER BY <var>columns</var>
LIMIT <var>offset</var>, <var>count</var></pre></div>

<h3>Aggregate Functions</h3>
<p>Aggregate functions are functions that operate on the data in
multiple rows. In other words, aggregate functions combine or aggregate
the data in multiple rows into one value. The aggregate functions
available in MySQL include MIN(), MAX(), COUNT(), SUM(), AVG(),
STDDEV(), and VARIANCE()</p>

<div class="pre">
<pre class="code language-sql">SELECT <var>aggregate_func(column)</var> AS <var>alias</var>, &hellip;
FROM <var>schema.table</var>
WHERE <var>filter</var>
GROUP BY <var>columns</var>
HAVING <var>aggregate_filter</var>
ORDER BY <var>columns</var>
LIMIT <var>offset</var>, <var>count</var></pre></div>

<h3>Join Tables</h3>
<p>Use a join to select columns from multiple tables.</p>

<div class="pre">
<pre class="code language-sql">SELECT <var>columns</var>
FROM <var>schema.table1</var> AS <var>t1</var>
    INNER JOIN <var>schema.table2</var> AS <var>t2</var> ON <var>t1.pk</var> = <var>t2.fk</var>
    INNER JOIN <var>schema.table3</var> AS <var>t3</var> ON <var>t2.pk</var> = <var>t3.fk</var>
    &vellip;
WHERE <var>filter</var>
ORDER BY <var>columns</var>
LIMIT <var>offset</var>, <var>count</var></pre></div>

<h3>Join Tables and Aggregate Functions</h3>
<div class="pre">
<pre class="code language-sql">SELECT <var>columns</var>, <var>aggregate_func(column)</var> AS <var>alias</var>, &hellip;
FROM <var>schema.table1</var> AS <var>t1</var>
    INNER JOIN <var>schema.table2</var> AS <var>t2</var> ON <var>t1.pk</var> = <var>t2.fk</var>
    INNER JOIN <var>schema.table3</var> AS <var>t3</var> ON <var>t2.pk</var> = <var>t3.fk</var>
    &vellip;
WHERE <var>filter</var>
GROUP BY <var>columns</var>
HAVING <var>aggregate_filter</var>
ORDER BY <var>columns</var>
LIMIT <var>offset</var>, <var>count</var></pre></div>

<p>Of course a single query can include elements from all the templates.
For example, a single query can</p>
<ul>
    <li><div>select columns from multiple tables with a join</div></li>
    <li><div>select values calculated using the arithmetic operators</div></li>
    <li><div>select values calculated using the scalar functions</div></li>
    <li><div>select values calculated using the aggregate functions</div></li>
    <li><div>filter the results</div></li>
    <li><div>group the results</div></li>
    <li><div>sort the results</div></li>
    <li><div>and much more</div></li>
</ul>

<h3>Execution Order</h3>
<p>In the next template, the numbers on the left show the order in which
the computer executes the clauses of a SQL query. Notice that the
<code>FROM</code> clause is executed first even though a developer
writes it second (after the <code>SELECT</code> clause). This execution
order helps us understand why a table alias defined in the
<code>FROM</code> clause may be used in all other clauses. The execution
order also helps us understand why a column alias defined in the
<code>SELECT</code> clause may not be used in the <code>FROM</code>,
<code>WHERE</code>, <code>GROUP BY</code>, or <code>HAVING</code>
clauses. A column alias defined in the <code>SELECT</code> clause may be
used only in the <code>ORDER BY</code> and <code>LIMIT</code> clauses
because the computer executes <code>ORDER BY</code> and
<code>LIMIT</code> after <code>SELECT</code>.</p>

<div class="pre">
<pre class="code language-sql">5. SELECT <var>columns</var>, <var>aggregate_func(column)</var> AS <var>alias</var>, &hellip;
1. FROM <var>schema.table1</var> AS <var>t1</var>
       INNER JOIN <var>schema.table2</var> AS <var>t2</var> ON <var>t1.pk</var> = <var>t2.fk</var>
       INNER JOIN <var>schema.table3</var> AS <var>t3</var> ON <var>t2.pk</var> = <var>t3.fk</var>
       &vellip;
2. WHERE <var>filter</var>
3. GROUP BY <var>columns</var>
4. HAVING <var>aggregate_filter</var>
6. ORDER BY <var>columns</var>
7. LIMIT <var>offset</var>, <var>count</var></pre></div>

</article>
</body>
</html>
